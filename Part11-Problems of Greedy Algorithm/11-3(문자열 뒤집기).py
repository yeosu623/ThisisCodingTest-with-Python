#11-3. 문자열 뒤집기
#풀이
#경우의 수가 2가지가 있다.
#1. 10001010 처럼 1,0 구간 갯수가 같은 경우
#2. 10001011 처럼 1,0 구간 갯수가 다른 경우

#구간마다 튀어나오게 하는 경우
#횟수 : 구간의 개수

# 한 구간은 압축이 가능하므로,
# 01010101에서 가장 효율적인 방법을 찾으면 된다.
# 구간을 가장 빠르게 줄여나가는 방법을 택한다.
# 1. 구간을 튀어나오게 한다.
# 01010101에서
# 01110101으로.
# 이 경우 8개의 구간이 6개로 줄어들었다. 즉 2개가 줄어들었다.
# 그런데 한 구간이 붙어있는 곳의 구간은 "2개"이다.
# 따라서 이거보다 효율적인 방법은 없다.

#----------
#풀이 정리
#정리하다면, 다음의 두 가지를 고려해야 한다.
#1. 1,0 구간의 갯수가 같은가? 다른가?
#2. 111, 000처럼 연속된 숫자는 한 구간으로 친다.
#그러면 모든 숫자는 101010..., 10101 이 두 가지 경우만 생긴다.
#3. 한 구간을 뒤집는 형식으로 진행한다. 이러면 2개의 구간을 없앨 수 있다.
#한 구간이 붙어있는 구간은 2개이므로, 이게 가장 효율적인 방식이다.

#----------

#알고리즘
#1. 1,0 구간 갯수를 확인한다.
#같은 경우(짝수 개)의 행동 횟수: 구간 갯수 / 2
#다른 경우(홀수 개)의 행동 횟수: (구간 갯수 -1) / 2

#----------

#코드
#시작 구간
S = input()

#풀이 구간
import time
start_time = time.time()

section = 1
section_setting = S[0] #현재 구간은 0인가, 1인가? 를 설정하는 변수

for idx in range(1, len(S)): #구간 갯수 확인
    if(section_setting == S[idx]):
        continue
    else:
        section_setting == S[idx]
        section += 1

result = section // 2

#끝 구간
end_time = time.time()
print("행동의 최소 횟수 : ", result)
print("경과 시간: ", end_time - start_time)
